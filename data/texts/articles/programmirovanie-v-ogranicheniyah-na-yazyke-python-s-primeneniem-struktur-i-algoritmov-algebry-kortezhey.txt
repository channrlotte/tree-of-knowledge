УДК 004.832
12 1 А.А. Зуенко ' , А.А. Алмаматов
1	Институт информатики и математического моделирования технологических процессов Кольского НЦ РАН
2	Кольский филиал Петрозаводского государственного университета
ПРОГРАММИРОВАНИЕ В ОГРАНИЧЕНИЯХ НА ЯЗЫКЕ PYTHON С ПРИМЕНЕНИЕМ СТРУКТУР И АЛГОРИТМОВ АЛГЕБРЫ КОРТЕЖЕЙ*
Аннотация
В статье рассмотрены особенности существующих подходов к решению задач удовлетворения ограничений. Для решения подобных задач авторами предлагается применять методы локального поиска на основе анализа структур алгебры кортежей. Приводится сравнение предыдущей версии библиотеки алгоритмов алгебры кортежей, реализованной на языке С++, и текущей версии библиотеки, разработанной на языке Python. Описаны преимущества использования интерпретируемых языков для создания среды программирования в ограничениях, представимых в структурах алгебры кортежей.
Ключевые слова:
программирование в ограничениях, алгебра кортежей, методы локального поиска, интерпретируемый язык программирования.
A.A. ZuenkO' A.A. Almamatov
CONSTRAINT PROGRAMMING BASED ON USING LANGUAGE PYTHON
AND PROPOSED STRUCTURES AND ALGORITHMS OF N-TUPLE ALGEBRA
Abstract
The article describes the features of the existing approaches to solving constraint satisfaction problems. To solve these problems the authors propose to use local search methods based on the analysis of the n-tuple algebra structures. The comparison of the previous version of the library of n-tuple algebra algorithms, implemented in C ++, and the current version of the library, developed in Python, is given. The advantages of using interpreted languages for creating an environment of constraint programming that can be represented in the n-tuple algebra structures is considered.
Keywords:
constraint programming, n-tuple algebra, local search methods, interpreted programming language.
Введение
Задача удовлетворения ограничений (CSP) - это тройка (V, D, C), где (1) V = (vb ..., vn} - множество переменных;
(2) D = {D1, ..., Dn} - множество доменов; каждый домен Dt - конечное множество, содержащее возможные значения, соответствующей переменной;
(3)	C = {C1, ., Cn} - множество ограничений.
Работа выполнена при финансовой поддержке РФФИ (проекты №№12-07-00550-а, 14-07-00205-а, 14-07-00256-а).
158
Ограничение С - отношение, определённое на подмножестве значений всех переменных, т.е. C с D1 х ... х Dn.
Заданная (частичная или полная) подстановка значений переменных удовлетворяет ограничению C, если каждая переменная получила такое значение, что соответствующий кортеж значений принадлежит C . Множество всевозможных подстановок для всех переменных является пространством, содержащим решение CSP-задачи.
Решением CSP-задачи является такая подстановка для всех переменных, при которой все ограничения удовлетворены. Если для некоторой задачи имеется, по крайней мере, одно решение, то задача является разрешимой, иначе - неразрешимой (противоречивой, переограниченной).
В некоторых случаях необходимо получить все решения. Иногда может быть сформулирована задача ограниченной оптимизации, а именно: найти такое решение, в котором значения переменных оптимизировали бы некоторый заданный функционал. Зачастую необходимо просто выяснить, разрешима ли задача. В любом случае, CSP-задачи принадлежат классу NP-полных задач [1].
В качестве известных примеров задачи удовлетворения ограничений можно привести [2]:
•	задача о раскраске карты;
•	задача о назначениях;
•	задача составления расписаний;
•	задачи транспортного планирования;
•	задачи комбинаторной оптимизации.
Существует два основных подхода к решению задач удовлетворения ограничений. Первый подход основан на методах систематического перебора решений. При этом перебор можно представить как обход дерева поиска, а путь до каждого листьевого узла описывается одним кортежем значений переменных.
Следует отметить две отличительные черты такого подхода:
1.	При существовании решений задачи они будут гарантированно найдены, в противном случае будет установлена неразрешимость задачи.
2.	Процедуры обхода дерева поиска обладают экспоненциальной сложностью, что делает задачу практически не решаемой без применения специализированных методов ускорения перебора.
Существуют также модификации методов обхода дерева в глубину, позволяющие сузить область поиска:
1.	Методы распространения ограничений, которые отсекают некоторые ветви дерева поиска, заведомо не удовлетворяющие условиям задачи. Это позволяет значительно сократить количество перебираемых вариантов. Однако сам способ отсечения ветвей сильно зависит от конкретной задачи и не гарантирует увеличения эффективности перебора в общем случае.
2.	Методы декомпозиции, осуществляющие разбиение задачи на несколько подзадач при условии, что комбинация их решений является решением исходной задачи. Как и в случае с распространением ограничений, есть сильная зависимость от специфики задачи.
Альтернативный подход основан на методах локального поиска - вместо систематического перебора всех возможных вариантов, выбор преемника текущего состояния задачи поиска зависит только от самого этого состояния. В
159
отличие от методов систематического перебора методы локального поиска обладают следующими преимуществами:
•	сравнительно низкой вычислительной сложностью относительно числа переменных;
•	при незначительном изменении условий уже решённой задачи можно использовать полученное для неё решение в качестве отправной точки для поиска новых решений;
•	алгоритмы подобного класса, как правило, легко поддаются распараллеливанию.
К недостаткам методов данного класса относится то, что они могут не найти решение CSP даже при его существовании, или найти лишь локальный экстремум оптимизируемой функции. Дело в том, что в пространстве состояний могут встречаться области, для которых нельзя выбрать преемника текущего состояния (соседнее состояние), улучшающего значение функции оценки. К таким областям можно отнести плато (участки пространства поиска, на которых функция оценки не изменяется) и хребты (последовательности близко расположенных локальных максимумов).
К алгоритмам локального поиска относятся:
•	генетические алгоритмы;
•	алгоритмы лучевого поиска;
•	роевой интеллект: муравьиный алгоритм, пчелиный алгоритм, метод роя частиц и др.;
•	стохастические методы (имитация отжига).
В публикациях [3-5] описаны разработанные одним из авторов методы распространения ограничений и эвристического поиска, ориентированные на систематический поиск решений и использующие матрицеподобные структуры алгебры кортежей (АК). Алгебра кортежей - алгебраическая система, предназначенная для моделирования и анализа многоместных отношений, с ее помощью удобно анализировать ограничения с конечными доменами. Поиск на основе этих методов, в отличие от методов полного перебора, состоит из последовательности таких шагов, как а) редукция пространства поиска и b) выбор на основе эвристик того преемника текущей вершины дерева поиска, который способен быстрее всего привести к цели. Созданные методы поиска позволили на практике эффективно решать многие задачи CSP, имеющие высокую вычислительную сложность в теории.
Базовые структуры, операции и алгоритмы АК, использующие концепцию дерева поиска, реализованы в виде специализированной программной библиотеки [6]. При её создании был применим язык программирования C++ и RAD C++ Builder 6.
Далее в настоящей работе подробно рассматриваются недостатки упомянутой библиотеки, и предлагается подход к созданию среды для программирования задач удовлетворения ограничений в терминах АК, свободной от подобных недостатков и поддерживающей методы локального поиска, а также отвечающей современным требованиям к свободно распространяемому программному обеспечению.
160
Недостатки существующей библиотеки для работы с АК-объектами
Ранее разработанная библиотека продемонстрировала, что алгоритмы обработки АК-объектов могут эффективно выполняться на компьютерах [6]. Также при её создании была продумана общая архитектура программы; проанализированы структуры данных, пригодные для представления ключевых понятий АК; общий порядок работы с данными.
Несмотря на то, что данная программная система полностью работоспособна, её сопровождение, модификация и интеграция с другим программным обеспечением (ПО) сильно осложнены. Причиной этому послужили отчасти парадигмы самого языка С++, которые задавали архитектуру программы, а также используемый подход к разработке с ориентацией на использование собственного интерпретатора выражений для ввода и разбора команд.
В предыдущей версии библиотеки не поддерживались такие конструкции, как циклы, ветвления, отсутствовала возможность создавать пользовательские типы данных, описывать процедуры и функции на основе базовых функций, реализующих операции с АК-объектами. Обработка большого количества однотипных объектов осуществлялась с помощью отдельного класса, представляющего одномерный массив, доступ к его элементам осуществлялся с помощью единственного оператора - получения элемента по индексу. Для имитации циклической обработки элементов массива имелся фиксированный набор функций.
Графический интерфейс упомянутой библиотеки позволял исполнять операции с АК-объектами в интерактивном режиме, для чего был разработан собственный интерпретатор выражений, содержащих базовые операции с АК-объектами. Каждая базовая операция, как и все другие элементы АК-программы, была представлена отдельным классом на языке С++. Для использовании вновь введенной операции в АК-программе требовалось изменить программный код парсера выражений с последующей перекомпиляцией программы. Ввиду сложности внутреннего устройства парсера выражений, процесс его модификации был крайне трудоёмким, даже, несмотря на использование сторонних библиотек (например, boost.regex) для разбора сложных выражений.
Так же обстояла ситуация и с введением в систему пользовательских типов данных - требовалась модификация кода программы с ее последующей компиляцией и отладкой. В частности, для работы с доменами использовался класс AkDomain, и все возможные виды доменов, содержащих целые, вещественные, строковые значения, описывались как потомки этого класса. Потомки класса AkDomain создавались посредством спецификации определенного класса-шаблона С++. При этом отсутствовала возможность определить в классах-потомках методы, специфичные для различных доменов (например, разбиение интервального домена, которое приходилось выполнять вне класса с помощью сторонних функций). Такой подход не позволял хранить разнотипные данные в пределах одного домена.
Использование собственного интерпретатора команд среды разработки АК-программ привело к тому, что большая часть деталей внутренней реализации классов оказалась неотделима от реализации самого оконного
161
интерфейса - в ряде случаев библиотека использует данные, хранящиеся в экземплярах класса интерфейса. Это накладывает большие ограничения на доработку и использование библиотеки, а также лишает библиотеку кросплатформенности и усложняет разработку версий с другими режимами работы (неинтерактивный режим, работа с использованием удалённых вызовов).
Входные данные для работы библиотеки и результаты выполнения алгоритмов АК могут передаваться с помощью: а) графического интерфейса; b) xml-файлов, где хранится АК-программа и необходимые ей данные; c) COM-вызовов от других программ или скриптов.
К недостаткам реализации библиотеки можно отнести и отсутствие команд управления памятью: не поддерживается возможность освобождения памяти от неиспользуемых объектов.
Среди менее существенных недостатков, не являющихся непосредственно следствием архитектуры, можно выделить следующие:
1.	Слабо мотивированный выбор структур данных для хранения
объектов. В исходной программе для хранения АК-объектов использовался контейнер типа «список». При этом хранящейся объекты имеют строковый идентификатор, представляющий собой название переменной, а основными операциями со списком служат:	итерация, поиск элемента по ключу,
удаление/добавление элемента по ключу. Данные с таким набором базовых операций предпочтительно хранить в словарях со строковым ключом или деревьях.
2.	Преобразование объектов в строковый вид. Программный пользовательский интерфейс библиотеки позволял генерировать для объектов АК-программ собственное представление, используя html-код, а также mathml-код. Однако формировались эти представления путем конкатенации строк, представляющих подобъекты рассматриваемых объектов, с использованием множества вложенных циклов. Такой подход делает данные функции неудобными для редактирования и трудными для чтения, а также жестко ограничивает способы представления результатов.
3.	Отсутствие возможности выбирать режимы просмотра результатов. Командный процессор создаёт текстовое представление для результата выполнения любого выражения, даже если данное значение является промежуточным и не нуждается в визуализации.
Таким образом, дальнейшее развитие данной версии библиотеки для работы с АК-объектами сильно осложнено, и целесообразно рассмотреть возможность переписывания функций, методов, классов с использованием другого языка программирования, парадигмы которого будут больше подходить для создания среды разработки АК-программ.
Требования к разрабатываемой среде программирования в ограничениях
Для языка программирования в ограничениях крайне желательно наличие возможности интерактивного взаимодействия, которое может осуществляться как в “консольном” и “безоконном” режимах, так и с помощью более сложного графического интерфейса, возможно, удалённо и/или распределено.
162
Чтобы максимально упростить структуру классов библиотеки, необходима поддержка объектно-ориентированного программирования (ООП). Реализуемые с помощью библиотеки алгоритмы имеют перспективы в области использования параллельных вычислений, поэтому преимуществом будет наличие средств для работы с различными моделями распределённых вычислений.
Также желательна поддержка в языке элементов функционального программирования (ФП) - парадигмы программирования, где процесс вычислений трактуется как вычисление значений математических функций. Наибольший интерес представляют функции, принимающие в качестве аргументов или возвращающие другие функции. Возможности ФП, связаны с оптимизацией и распараллеливанием вычислений.
Кроме того, приветствуется наличие в программном пакете научных библиотек для алгоритмов локального поиска и других методов решения задач удовлетворения ограничений.
С точки зрения авторов наиболее отвечают предъявляемым требованиям такие языки программирования, как:
a)	Lua - интерпретируемый язык программирования близкий к JavaScript;
b)	язык среды Matlab - язык среды для выполнения технических вычислений и также используемый в ней язык;
c)	R - язык программирования, используемый для научных и статистических расчётов;
d)	Python - высокоуровневый язык программирования общего назначения.
В таблице представлена сравнительная характеристика проанализированных языков программирования.
Сравнение параметров рассматриваемых языков
Язык	lua	R	Matlab	Python
Интерпретируемость	Да	Да	Да	Да
Поддержка ООП	Да	Да	Да	Да
Доступ к низкоуровневым структурам данных	Да	Нет	Нет	API для встраивания C-функций в программу
Средства для сетевого взаимодействия	Нет	В составе некоторых внешних библиотек	Интерфейсы для наиболее распространённых средств	Средства вебразработки и поддержка известных протоколов
Средства для распределённых и многопоточных вычислений	Нет	Да	Да	Да
Элементы функционального программирования	Нет	Да	Да	Да
163
окончание таблицы
Большое количество вспомогательных библиотек	Нет	Да	Да	Да
Тип лицензии	Свободное ПО (Лицензия MIT)	Свободное ПО (GNU GPL)	Проприетар -ное ПО	Свободное ПО (PSFL)
С учетом перечисленных характеристик и их приоритетов для разработки среды для работы с АК-объектами было решено использовать язык Python.
Возможности языка Python
В программе на языке Python [7, 8] любая сущность представлена специальным классом, и любой используемый в программе объект представлен его экземпляром. Фактически имеется большое сходство с подходом, применяемом в С++.
Для работы с программами доступны несколько режимов работы [9]:
•	Интерактивный режим (режим диалога). В данном случае интерпретатор обрабатывает, как команды, строки, вводимые пользователем.
•	Выполнение инструкций из файла. Интерпретатор обрабатывает команды, содержащиеся в переданном файле. Программы могут быть как обычными скриптами, так и работающими в фоновом режиме процессами.
В программах на языке Python можно использовать функции, написанные на C, что оказывается полезным для ускорения низкоуровневых операций [10].
Python обладает средствами функционального программирования: генераторы, итераторы, встроенные функции (map, reduce, filter, apply).
Существуют библиотеки для распределённых/параллельных вычислений с использованием языка Python. Также написано множество фреймворков для работы с кластерами, облачными сервисами, grid-сетями.
Имеются библиотеки и встроенные средства для осуществления сетевого взаимодействия, удалённого запуска и вызова функций (RPC). Существуют библиотеки и фреймворки как для синхронного, так и для асинхронного режимов работы. Поддерживается взаимодействие между клиент-серверными приложениями с использованием сокетов, интерфейсов COM, имеется встроенная библиотека с реализацией RPC, большое количество высокоуровневых протоколов.
Доступны библиотеки для поддержки научных расчетов на языке Python, обработки различных типов данных, визуализации полученных результатов [11]. Из наиболее известных библиотек можно перечислить следующие:
•	NumPy - библиотека для обработки больших объемов данных, представленных, как правило, в виде больших матриц и массивов. Частично написана на С для повышения производительности работы алгоритмов.
•	SciPy - библиотека, объединяющая инструменты для научных вычислений, в частности средства для интегрирования и интерполяции функций, обработки изображений, решения дифференциальных уравнений, генетические алгоритмы и пр.
164
•	MatPlotLib - библиотека для визуализации данных, поддерживает возможность отображать данные в различных графических форматах. Обычно идёт в связке с NumPy и SciPy.
•	Pandas - многоцелевая высокопроизводительная библиотека, используемая для моделирования и анализа данных. Библиотека ориентирована на работу с разнородными форматами данных.
•	Sympy - библиотека для символьных вычислений. Применяется для решения уравнений, интегрирования, дифференцирования, комбинаторных задач, дискретных задач, физических уравнений и т. д.
•	IPython - интерактивная оболочка для языка Python. Предоставляет больше возможностей по сравнению со стандартным терминалом Python. Имеет несколько вариантов интерфейсов, в т.ч. с использованием веб-браузера. Поддерживает вывод графических данных непосредственно в терминал, также может использоваться для управления параллельными вычислительными кластерами [7].
•	Python(x, y) - научное ПО, включающее в себя интерпретатор Python и множество библиотек для научных вычислений. Содержит модули для визуализации данных, машинного обучения, численных вычислений и т. д.
•	Spyder - среда для разработки программ на языке Python и выполнения научных вычислений. Включает в себя встроенную документацию, отладчик, консоль IPython, средства графического ввода и просмотра данных. Поддерживает оперативный поиск ошибок.
Далее перечислим некоторые библиотеки, разработанные для решения задач удовлетворения ограничений на языке Python:
•	пакет библиотек logilab имеет модуль constraint, использующийся для решения задач программирования в ограничениях;
•	ПО Cassowary constraint solver для решения задач программирования в ограничениях имеет интерфейс для Python.
Теперь назовем библиотеки, позволяющие создавать генетические алгоритмы и методы локального поиска:
•	Pygene - библиотека для работы с генетическими алгоритмами и методами генетического программирования. Позволяет гибко настраивать механизмы мутаций, наследования свойств, величины популяции, появления полностью случайных конфигураций генов.
•	DEAP - библиотека для выполнения эволюционных вычислений. Используется, как правило, для быстрого прототипирования. Поддерживает много вариаций генетических алгоритмов, таких как NSGA-II, SPEA-II, CMA-ES. Кроме генетических алгоритмов предоставляются алгоритмы роевого типа, алгоритмы стохастической оптимизации и др. [12].
•	Pyevolve - быстрый расширяемый фреймворк для генетического программирования. Поддерживает графический вывод результатов.
В языке Python существует множество IDE (Integrated Development Environment - интегрированная среда разработки) для разработки приложений с возможностями редактировать, выполнять, тестировать и отлаживать код. В качестве примеров можно привести Eclipse^ использованием плагина pydev), IDLE, Eric, PyCharm, Visual Studio (c использованием Python tools).
165
Таким образом, в языке Python имеется множество специализированных инструментов для решения задач удовлетворения ограничений, что освобождает от необходимости разрабатывать собственную среду программирования в ограничениях. Для поддержки возможности обработки ограничений с конечными доменами авторами было принято решение дополнить стандартизированные средства языка Python дополнительными возможностями вывода на ограничениях с использованием АК-объектов.
Особенности реализации разрабатываемой среды программирования в ограничениях
Для использования в программе возможностей разработанной библиотеки её необходимо подключить с помощью команды import. После этого становятся доступными классы для создания АК-объектов и функции работы с ними.
Ниже приводится пример кода для создания АК-объектов средствами рассматриваемой библиотеки: import AK
doml = AK.domain([1, 2, 3]) #создание домена с помощью списка чисел;
attrl = AK.attribute(dom1) #атрибут, основанный на домене;
attr2 = AK.attribute(dom1) #второй атрибут, основанный на домене;
scm = AK.scheme([attr1, attr2]) #схема;
sys 1 = AK.csystem(scm).
Хранение переменных можно осуществлять как в переменных поставляемой среды разработки программ на языке Python, так и внутри спроектированного авторами класса AK.main. Несмотря на то, что в новой версии отсутствует необходимость использования специального класса-контейнера для АК-объектов, akmain по-прежнему выполняет ряд важных функций: сериализацию, десериализацию, группировку объектов для их последующего использования во внешних модулях.
Ниже приведён пример работы с АК-объектами с применением экземпляра класса akmain: import AK AKM = AK.main()
AKM['D1'] = AK.domain(range(20 ))
#range(20) - автоматическая генерация чисел в диапазоне от 0 до 19 AKM['D2'] = AK.domain('abcdef)
#Строка является итерируемым объектом, поэтому её передача эквивалентна передаче списка отдельных символов, из которых она состоит AKM['A1'] = AK.attribute(AKM['D1'])
AKM['A2'] = AK.attribute(AKM['D2'])
AKM['U1'] = AK.scheme([AKM['A 1'], AKM['A2']])
result = AKM.htlm() #Получение строки с html-кодом всех созданных объектов.
Библиотека состоит из перечисленных ниже программных модулей:
•	akrandom.py - модуль библиотеки, используемый для генерации АК-объектов с их автоматическим заполнением;
•	attribute.py - модуль, содержащий реализацию класса для атрибута АК-объекта;
166
•	chances.py - классы AttributeChances и SchemeChances для вероятностных пространств;
•	com.py - модуль, предоставляющий доступ к COM-интерфейсу и требующий для функционирования отдельно установленной библиотеки (pywin);
•	component.py - реализация класса, компоненты АК-объекта;
•	domain.py - реализация класса для АК-домена;
•	fetch.py - вспомогательные функции для работы с переменными;
•	main.py - реализация класса akmain;
•	row.py - класс для представления АК-систем в виде строки;
•	scheme.py - реализация класса для представления АК-схемы;
•	templates.py - шаблоны, используемые для генерации html-представления АК-объектов;
•	viewer.py - просмотрщик АК-объектов на GTK, который требует для работы отдельно установленной библиотеки (pygtk).
На рис.1. представлена диаграмма классов спроектированной на языке Python библиотеки.
Библиотека снабжена специализированным графическим интерфейсом для редактирования АК-объектов с помощью gtk-виджетов. Потребность в нём вызвана, прежде всего, тем, что консоль Python предоставляет достаточно слабые средства интерактивного взаимодействия с пользователем.
Далее приведем основные отличия в реализации базовых классов разработанной библиотеки от предыдущей версии.
Класс “Домен”. Конструктор класса “Домен” принимает в качестве одного из аргументов любой поддерживающий итерацию объект-список, где перечислены используемые значения. В текущей версии библиотеки не разрешается изменять содержимое данного списка. Таким образом, исключена возможность редактирования (добавления и удаления элемента) уже созданного домена.
Благодаря использованию универсального контейнера спискового типа данный класс можно использовать для представления любого типа доменов. Также для специфических наборов данных присутствует возможность создания потомков класса, для которых могут быть определены дополнительные методы (например, методы квантования для интервальных доменов).
Класс “Атрибут”. Отсутствуют значимые изменения.
Класс “Схема”. Как и для класса “Домен”, в новой версии для класса “Схема” запрещено редактирование его содержимого в ходе исполнения программы. Конструктор класса принимает в качестве аргумента любой поддерживающий итерацию объект, содержащий список атрибутов данной схемы.
Класс “АК-кортеж”. В текущую реализацию библиотеки добавлен специализированный класс для обработки кортежей АК-объектов.
Класс “АК-объект”. Все операции над АК-объектами реализованы в виде перегруженных операторов языка Python. Таким образом, благодаря использованию возможностей поставляемого интерпретатора языка Python, отпадает необходимость в поддержке отдельно реализованного разбора выражений.
167
list	AKSystem
add	fx, у)	init	(self, scm, name=")
contains	(х, у)	setComponentFromData(self, column, row, data)
delitem	(х, у)	iter	(self)
delslice	(х, i, j)	len	(self)
—eq—(л, у)	getitem	(self, index)
—0е—(*, у)	appendfself, newrow)
getattribute	(..)	Ad d_e m pty_row (s e If)
getitem	(x, у)	Add_full_row(self)
getslice	(x, i, j)	Delete_row(self, row_num)
У)	UniteRowsfself, arg)
iadd	(x, y)	IntersectRowsfself, arg)
imul	(x, y)	Compatible(self, arg)
iter	(x)	projection(self, newscm)
sort(L, cmp=None, key=None, reverse=False)	xml(self, parent)
AKRow
Indexing(self)
___hash___(self)
___init_(self, scheme=None, full-False)
___str_(self)
copy(self)
flipped(self)
have_e m pty_co m po n ent(s elf)
have_full_component(self)
html(self)
intersection(self, arg) is_subset_of(self, arg) mathml(self) split(self) xmlfself, parent)
AKCSystem
AKDSystem
AKDomain
___getitem___(self, index)
___init_(self, content=[], domtype=-1, name=
___iter_(self)
___len__(self)
___str__(self)
comp_from_elems(self, elems)
html(self)
indexfself, elem)
indices(self, elems)
mathml(self)
xmlfself, parent)
AKScneme	AKMain
eq	(self, arg)	getitem	(self, key)
getitem	(self, index)	init	(self, xml_filename=None, xml_chances_filename=None)
init	(self, attrs, name=")	iter	(self)
iter	(self)	setitem	(self, key, value)
len	(self)	chances_xml(self)
ne	(self, arg)	full_html(self)
str	(self)	full_mathml(self)
allSubSchemes(self)	ntml(selt)
attrs_string(self)	load_chances_xml(self, filename)
html(self)	load_xml(self, filename)
indexfself, attr)	mathml(self)
iter_domains(self)	parseAttribute(self, node)
mathml(self)	parseChances(self, node)
xmlfself, parent)
xml(self)
AKAttribute
___init_(self, domain, name=")
___iter_(self)
___len__(self)
___str__(self)
comp_1rom_elems(self, elems)
html(self)
mathml(self)
xml(self, parent)
AKComponent
___init_(self, domain, full=False)
from_elems(self, elems, empty=False)
set(self, index)
copy(self)
___str__(self)
is_subset_of(self, arg)
any(self)
all(self)
none(selt)
flip_elem(self, index) flipped(self) bitset(self) elems(self)
xml(self, parent)
AttrlbuteChances
___init_(self, attr, chances=[], name=")
___len___(self)
___iter__(self)
___getitem___(self, index)
___setitem___(self, index, value)
Galculate(self, component)
html(self)
mathml(self)
xmlfself, parent)
SchemeChances
___init_(self, scm, chances=None, name=")
__getitem___(self, index)
__iter__(self)
Calculate_Row(self, row)
Calculate_CSystem(self, system)
xmlfself, parent)
html(self)
mathml(self)
Рис. 1. Структура используемых в библиотеке классов
Класс “Компонента АК-объекта”. Хранение в данном классе битового кортежа, моделирующего подмножество значений домена некоторого атрибута, реализовано с помощью длинных целых чисел. Например, компонента, бинарное представление которой записывается как вектор “101”, будет храниться в виде числа 5. Операции пересечения и объединения выполняются с помощью побитовых операций над числами, поддерживаемых в Python.
Реализация операций с АК-объектами. Несмотря на использование перегруженных операторов языка Python, базовые операции АК были также реализованы с помощью отдельных методов класса АК-систем. Это обеспечивает возможность импорта выражений из XML-файлов, проверки типов результатов выражений до непосредственного выполнения вычислений, а также предоставляет возможность организовывать ленивые вычисления.
168
Класс “AKMain” - Класс “АК-программы”. В отличие от AKMain предыдущей версии библиотеки, данный класс не привязан к интерфейсу. Хранение объектов осуществляется в словаре, а не списке, изменились способы поиска и доступа. Появилась возможность создавать несколько экземпляров AKMain в пределах одной программы.
В завершении обзора преимуществ разработанной авторами библиотеки рассмотрим предоставляемые ей возможности визуализации данных. Поддерживается несколько способов визуализации данных - с помощью gtk-виджетов и html кода. Опционально может использоваться Mathml.
Обеспечена поддержка разработки оконных интерфейсов с помощью библиотеки GTK+, которая содержит элементы для построения пользовательского графического интерфейса.
Для генерации htm - и mathml - представлений экземпляров класса «АК-объект» используется специализированный шаблонизатор из библиотеки jinja2. Это позволяет отделить представление (материализацию) от кода и использовать сразу несколько представлений, загружать шаблоны извне.
Просмотр результата можно выполнить с помощью браузера или в среде разработки программ на языке Python, если она поддерживает вывод результата в виде html/mathml кода.
Ниже приводится пример шаблона для генерации представления класса «АК-объект».
<table class='matrix-values'>
{% for row in system %}
<tr>
{% for comp in row%}
<td> {{ comp.elems_string() }} </td>
{% endfor %}
</tr>
{% endfor %}
</table>
Заключение
Рассмотрены основные недостатки существующей библиотеки для работы с АК-объектами, затрудняющие её развитие и использование вместе с другими программными средствами.
Описана созданная с применением языка Python библиотека, позволяющая выполнять операции АК, её структура, режимы работы, а также отличия от предыдущей версии библиотеки.
В качестве перспектив развития можно отметить следующие направления:
•	интеграция системы с библиотеками или фреймворками, работающими с генетическими алгоритмами и поддерживающими решение задач программирования в ограничениях;
•	ускорение низкоуровневых операций с использованием Python C-API;
•	развитие системы удалённого взаимодействия для реализации возможности удалённого управления и распараллеливания операций.
169
Литература
1.	Осипов, Г.С. Методы искусственного интеллекта / Г.С. Осипов. - М.: Физматлит, 2011. - 296 с.
2.	Щербина, О.А. Удовлетворение ограничений и программирование в ограничениях / О.А. Щербина // Интеллектуальные системы. - 2011. -Т.15, вып. 1-4. - С.54-73.
3.	Зуенко, А.А. Вывод на ограничениях с применением матричного представления конечных предикатов /А.А. Зуенко // Искусственный интеллект и принятие решений. - 2014. - №3. - C.21-31.
4.	Зуенко, А.А. Распространение ограничений и эвристический поиск с применением матричного представления конечных предикатов / А.А. Зуенко // КИИ- 2014, г. Казань, 24-27 сентября 2014 г.: труды Четырнадцатой национальной конференция по искусственному интеллекту с международным участием. - Казань: Изд-во РИЦ «Школа», 2014. -Т.1. -C.32-40.
5.	Зуенко, А.А. Обработка специальных видов ограничений при решении задач удовлетворения ограничений в структурах алгебры кортежей / А.А. Зуенко // КИИ- 2014, г. Казань, 24-27 сентября 2014 г.: труды Четырнадцатой национальной конференция по искусственному интеллекту с международным участием. - Казань: Изд-во РИЦ «Школа», 2014. -Т.1. - C41-49.
6.	Зуенко, А.А. Реализация библиотеки АК-объектов / А.А. Зуенко, С.В. Баженов // Труды Кольского научного центра РАН. Информационные технологии. - Вып.3. -4/2012(11), Апатиты: Изд-во КНЦ РАН, 2012. - С.207-217.
7.	The Python Language Reference:	Data Model. - Режим доступа:
https: //docs.python.org/2/reference/datamodel.html.
8.	Index of Python Enhancement Proposals >> PEP 252: Making Types Look More Like Classes. - Режим доступа: http://legacy.python.org/dev/peps/pep-0252/.
9.	Rossum, G. An Introduction to Python / G. Rossum, F.L. Drake - Network Theory Ltd. - 2011 - С.7-10.
10.	Behnel, S. Cython tutorial. Proceedings of the 8th Python in Science Conference(SciPy 2009) / R.W. Bradshaw, D.S. Seljebotn. - Режим доступа: http://conference.scipy.org/proceedings/scipy2009/paper_2/full_text.pdf
11.	Johansson, J. Introduction to scientific computing with Python. - Режим доступа: http://nbviewer.ipython.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-0-Scientific-Computing-with-Python.ipynb
12. A Python Framework for Evolutionary Algorithms. - Режим доступа: http://vision.gel.ulaval.ca/~cgagne/pubs/deap-gecco-2012.pdf
Сведения об авторах
Зуенко Александр Анатольевич - к.т.н, научный сотрудник,
е-mail: zuenko@iimm. ru
Alexander A. Zouenko - Ph.D. (Tech. Sci.), researcher
Алмаматов Александр Анатольевич - младший научный сотрудник,
е-mail: [email protected]
Alexander A. Almamatov - junior researcher
170
